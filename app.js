// ZetaChain Universal Portfolio Tracker
// Universal App with Gateway Integration
// Architecture Generated by Amazon Q Developer

class PortfolioTracker {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.userAddress = null;
        
        // Contract configuration
        this.CONTRACT_ADDRESS = "0x2398C02218e5aa5b759f511F3DD56283fDBb5497"; // ZetaChain testnet contract
        this.GATEWAY_ADDRESS = "0x6c533f7fe93fae114d0954697069df33c9b74fd7";
        
        // Extended ABI with Universal NFT functions
        this.CONTRACT_ABI = [
            "function deposit(uint256 amount) external payable",
            "function withdrawAndTrack(uint256 positionId, uint256 destinationChainId, address destinationAddress, uint256 gasLimit) external payable",
            "function getPosition(address user, uint256 positionId) external view returns (tuple(uint256 amount, address user, uint256 timestamp, uint8 status, bytes32 crossChainTxHash, uint256 destinationChainId))",
            "function getUserPositions(address user) external view returns (tuple(uint256 amount, address user, uint256 timestamp, uint8 status, bytes32 crossChainTxHash, uint256 destinationChainId)[])",
            "function estimateWithdrawGas(uint256 gasLimit) external view returns (uint256 baseGas, uint256 withPremium)",
            // Universal NFT Functions
            "function hasUsedSafetyBuffer(address user) external view returns (bool)",
            "function isEligibleForBadge(address user) external view returns (bool)",
            "function getUserBadge(address user) external view returns (uint256)",
            "function mintSafetyBadge() external",
            "function transferBadgeCrossChain(uint256 tokenId, uint256 destinationChainId) external",
            "function ownerOf(uint256 tokenId) external view returns (address)",
            "function tokenURI(uint256 tokenId) external view returns (string)",
            // Additional View Functions
            "function getPositionCount(address user) external view returns (uint256)",
            "function totalDeposited(address user) external view returns (uint256)",
            "function gateway() external view returns (address)",
            // Emergency Functions
            "function emergencyWithdraw(uint256 positionId) external",
            // Events
            "event PositionCreated(address indexed user, uint256 positionId, uint256 amount)",
            "event WithdrawInitiated(address indexed user, uint256 positionId, bytes32 txHash)",
            "event SafetyBufferUsed(address indexed user, uint256 positionId)",
            "event SafetyBadgeMinted(address indexed user, uint256 tokenId)",
            "event BadgeTransferredCrossChain(uint256 indexed tokenId, uint256 destinationChainId, address recipient)"
        ];
        
        this.init();
    }
    
    async init() {
        this.setupEventListeners();
        await this.checkWalletConnection();
    }
    
    setupEventListeners() {
        document.getElementById('connectWallet').addEventListener('click', () => this.connectWallet());
        document.getElementById('depositBtn').addEventListener('click', () => this.createPosition());
        document.getElementById('withdrawBtn').addEventListener('click', () => this.withdrawPosition());
        document.getElementById('gasLimit').addEventListener('input', () => this.updateGasEstimate());
        document.getElementById('positionSelect').addEventListener('change', () => this.updateGasEstimate());
        
        // Universal NFT event listeners
        document.getElementById('mintBadgeBtn').addEventListener('click', () => this.mintSafetyBadge());
        document.getElementById('transferBadgeBtn').addEventListener('click', () => this.transferBadge());
        document.getElementById('transferChain').addEventListener('change', (e) => {
            document.getElementById('transferBadgeBtn').disabled = !e.target.value;
        });
    }
    
    async checkWalletConnection() {
        if (typeof window.ethereum !== 'undefined') {
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    await this.connectWallet();
                }
            } catch (error) {
                console.error('Error checking wallet connection:', error);
            }
        }
    }
    
    async connectWallet() {
        try {
            if (typeof window.ethereum === 'undefined') {
                this.showError('Please install MetaMask to use this application');
                return;
            }
            
            if (!this.CONTRACT_ADDRESS || this.CONTRACT_ADDRESS === "") {
                this.showError('Contract not deployed yet. Please deploy the contract first and update CONTRACT_ADDRESS in app.js');
                return;
            }
            
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            this.provider = new ethers.providers.Web3Provider(window.ethereum);
            this.signer = this.provider.getSigner();
            this.userAddress = await this.signer.getAddress();
            
            await this.switchToZetaChain();
            
            this.contract = new ethers.Contract(this.CONTRACT_ADDRESS, this.CONTRACT_ABI, this.signer);
            
            await this.updateWalletInfo();
            await this.loadPositions();
            await this.loadUserStats(); // NEW: Load user statistics
            await this.checkBadgeEligibility(); // NEW: Check NFT eligibility
            
            document.getElementById('connectWallet').style.display = 'none';
            document.getElementById('walletInfo').classList.remove('hidden');
            document.getElementById('depositBtn').disabled = false;
            
            this.showSuccess('Wallet connected successfully!');
            
        } catch (error) {
            console.error('Error connecting wallet:', error);
            this.showError('Failed to connect wallet: ' + error.message);
        }
    }
    
    async switchToZetaChain() {
        try {
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x1b59' }],
            });
        } catch (switchError) {
            if (switchError.code === 4902) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x1b59',
                            chainName: 'ZetaChain Athens Testnet',
                            nativeCurrency: {
                                name: 'ZETA',
                                symbol: 'ZETA',
                                decimals: 18
                            },
                            rpcUrls: ['https://zetachain-athens-evm.blockpi.network/v1/rpc/public'],
                            blockExplorerUrls: ['https://athens3.explorer.zetachain.com/']
                        }]
                    });
                } catch (addError) {
                    throw new Error('Failed to add ZetaChain network');
                }
            } else {
                throw switchError;
            }
        }
    }
    
    async updateWalletInfo() {
        const balance = await this.provider.getBalance(this.userAddress);
        document.getElementById('walletAddress').textContent = 
            `Address: ${this.userAddress.slice(0, 6)}...${this.userAddress.slice(-4)}`;
        document.getElementById('walletBalance').textContent = 
            `Balance: ${ethers.utils.formatEther(balance)} ZETA`;
    }
    
    async createPosition() {
        try {
            const amount = document.getElementById('depositAmount').value;
            if (!amount || parseFloat(amount) <= 0) {
                this.showError('Please enter a valid deposit amount');
                return;
            }
            
            // Check balance first
            const balance = await this.provider.getBalance(this.userAddress);
            const amountWei = ethers.utils.parseEther(amount);
            
            if (balance.lt(amountWei)) {
                this.showError(`Insufficient balance. You have ${ethers.utils.formatEther(balance)} ZETA but need ${amount} ZETA. Get more from: https://labs.zetachain.com/get-zeta`);
                return;
            }
            
            // Check network
            const network = await this.provider.getNetwork();
            if (network.chainId !== 7001) {
                this.showError('Wrong network! Please switch to ZetaChain Athens Testnet (Chain ID: 7001)');
                return;
            }
            
            this.showLoading('Creating position...');
            
            console.log('Sending transaction:', {
                amount: amount,
                amountWei: amountWei.toString(),
                balance: ethers.utils.formatEther(balance)
            });
            
            const tx = await this.contract.deposit(amountWei, { 
                value: amountWei,
                gasLimit: 300000 // Explicit gas limit
            });
            
            console.log('Transaction sent:', tx.hash);
            await tx.wait();
            console.log('Transaction confirmed');
            
            this.showSuccess('Position created successfully!');
            document.getElementById('depositAmount').value = '';
            
            await this.loadPositions();
            await this.loadUserStats();
            await this.updateWalletInfo();
            
        } catch (error) {
            console.error('Error creating position:', error);
            
            // Better error messages
            let errorMsg = 'Failed to create position: ';
            
            if (error.code === 'INSUFFICIENT_FUNDS') {
                errorMsg = 'Insufficient ZETA balance. Get more from: https://labs.zetachain.com/get-zeta';
            } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                errorMsg = 'Transaction will fail. Check: 1) You have enough ZETA, 2) You\'re on ZetaChain Athens, 3) Contract is deployed correctly';
            } else if (error.message.includes('user rejected')) {
                errorMsg = 'Transaction cancelled by user';
            } else {
                errorMsg += error.message;
            }
            
            this.showError(errorMsg);
        } finally {
            this.hideLoading();
        }
    }
    
    /**
     * Load user statistics
     */
    async loadUserStats() {
        try {
            if (!this.contract || !this.userAddress) return;
            
            const positionCount = await this.contract.getPositionCount(this.userAddress);
            const totalDeposited = await this.contract.totalDeposited(this.userAddress);
            
            document.getElementById('positionCount').textContent = positionCount.toString();
            document.getElementById('totalDeposited').textContent = 
                `${ethers.utils.formatEther(totalDeposited)} ZETA`;
                
        } catch (error) {
            console.error('Error loading user stats:', error);
        }
    }
    
    async loadPositions() {
        try {
            if (!this.contract || !this.userAddress) return;
            
            const positions = await this.contract.getUserPositions(this.userAddress);
            this.displayPositions(positions);
            this.updatePositionSelect(positions);
            
        } catch (error) {
            console.error('Error loading positions:', error);
        }
    }
    
    displayPositions(positions) {
        const container = document.getElementById('positionsContainer');
        
        if (positions.length === 0) {
            container.innerHTML = '<p class="no-positions">No positions found. Create your first position above.</p>';
            return;
        }
        
        const statusNames = ['Active', 'Withdrawn', 'Refunded', 'Failed', 'Pending'];
        const statusClasses = ['status-active', 'status-withdrawn', 'status-refunded', 'status-failed', 'status-pending'];
        const statusIcons = ['‚úÖ', 'üéØ', 'üîÑ', '‚ùå', '‚è≥'];
        
        container.innerHTML = positions.map((position, index) => `
            <div class="position-item">
                <div class="position-header">
                    <span class="position-id">Position #${index}</span>
                    <span class="position-status ${statusClasses[position.status]}">
                        ${statusIcons[position.status]} ${statusNames[position.status]}
                    </span>
                </div>
                <div class="position-details">
                    <div class="position-detail">
                        <strong>Amount</strong>
                        ${ethers.utils.formatEther(position.amount)} ZETA
                    </div>
                    <div class="position-detail">
                        <strong>Created</strong>
                        ${new Date(position.timestamp * 1000).toLocaleDateString()}
                    </div>
                    <div class="position-detail">
                        <strong>Status</strong>
                        ${statusNames[position.status]}
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    updatePositionSelect(positions) {
        const select = document.getElementById('positionSelect');
        
        select.innerHTML = '<option value="">Choose a position to withdraw</option>';
        
        positions.forEach((position, index) => {
            if (position.status === 0) {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Position #${index} - ${ethers.utils.formatEther(position.amount)} ZETA`;
                select.appendChild(option);
            }
        });
        
        const hasActivePositions = positions.filter(p => p.status === 0).length > 0;
        select.disabled = !hasActivePositions;
        document.getElementById('withdrawBtn').disabled = !hasActivePositions;
    }
    
    async updateGasEstimate() {
        try {
            const gasLimit = document.getElementById('gasLimit').value;
            const positionId = document.getElementById('positionSelect').value;
            
            if (!gasLimit || !positionId || !this.contract) return;
            
            const [baseGas, withPremium] = await this.contract.estimateWithdrawGas(gasLimit);
            
            document.getElementById('gasEstimate').textContent = 
                `${ethers.utils.formatEther(baseGas)} ZETA`;
            document.getElementById('gasPremium').textContent = 
                `${ethers.utils.formatEther(withPremium)} ZETA`;
                
        } catch (error) {
            console.error('Error estimating gas:', error);
        }
    }
    
    async withdrawPosition() {
        try {
            const positionId = document.getElementById('positionSelect').value;
            const destinationChain = document.getElementById('destinationChain').value;
            const destinationAddress = document.getElementById('destinationAddress').value;
            const gasLimit = document.getElementById('gasLimit').value;
            
            if (!positionId || !destinationAddress || !gasLimit) {
                this.showError('Please fill in all withdrawal fields');
                return;
            }
            
            if (!ethers.utils.isAddress(destinationAddress)) {
                this.showError('Please enter a valid destination address');
                return;
            }
            
            const [, gasFee] = await this.contract.estimateWithdrawGas(gasLimit);
            
            this.showLoading('Initiating cross-chain withdrawal with Volatility Premium...');
            
            const tx = await this.contract.withdrawAndTrack(
                positionId,
                destinationChain,
                destinationAddress,
                gasLimit,
                { value: gasFee }
            );
            
            await tx.wait();
            
            this.showSuccess('Withdrawal initiated! Safety Buffer used - Check your badge eligibility!');
            this.addTransactionStatus(tx.hash, 'Withdrawal Initiated (Volatility Premium Applied)');
            
            document.getElementById('positionSelect').value = '';
            document.getElementById('destinationAddress').value = '';
            
            await this.loadPositions();
            await this.loadUserStats();
            await this.updateWalletInfo();
            await this.checkBadgeEligibility(); // NEW: Recheck eligibility
            
        } catch (error) {
            console.error('Error withdrawing position:', error);
            this.showError('Failed to withdraw position: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    

    
    // ============ UNIVERSAL NFT FUNCTIONS ============
    
    /**
     * Check if user is eligible for Safety Badge NFT
     */
    async checkBadgeEligibility() {
        try {
            if (!this.contract || !this.userAddress) return;
            
            const isEligible = await this.contract.isEligibleForBadge(this.userAddress);
            const badgeTokenId = await this.contract.getUserBadge(this.userAddress);
            const hasBadge = badgeTokenId.toNumber() > 0;
            
            // Update UI based on status
            const badgeVisual = document.getElementById('badgeVisual');
            const badgeStatusText = document.getElementById('badgeStatusText');
            const badgeDescription = document.getElementById('badgeDescription');
            const badgeEligibility = document.getElementById('badgeEligibility');
            const mintBtn = document.getElementById('mintBadgeBtn');
            const transferChain = document.getElementById('transferChain');
            const transferBtn = document.getElementById('transferBadgeBtn');
            
            if (hasBadge) {
                // User has minted badge
                badgeVisual.className = 'badge-unlocked';
                badgeStatusText.textContent = 'Owned';
                badgeDescription.textContent = `You own Safety Badge #${badgeTokenId}. Transfer it to any chain!`;
                badgeEligibility.innerHTML = '‚úÖ Badge Minted';
                badgeEligibility.className = 'eligibility-status eligible';
                mintBtn.disabled = true;
                mintBtn.textContent = '‚úÖ Badge Already Minted';
                transferChain.disabled = false;
            } else if (isEligible) {
                // User is eligible to mint
                badgeVisual.className = 'badge-eligible';
                badgeStatusText.textContent = 'Eligible';
                badgeDescription.textContent = 'Congratulations! You used the Volatility Premium safely. Mint your Universal NFT badge now!';
                badgeEligibility.innerHTML = '‚úÖ Eligible to Mint';
                badgeEligibility.className = 'eligibility-status eligible';
                mintBtn.disabled = false;
            } else {
                // User not eligible yet
                badgeVisual.className = 'badge-locked';
                badgeStatusText.textContent = 'Locked';
                badgeDescription.textContent = 'Complete a safe withdrawal using the Volatility Premium to unlock your Universal NFT badge.';
                badgeEligibility.innerHTML = '‚ùå Not Eligible Yet';
                badgeEligibility.className = 'eligibility-status';
                mintBtn.disabled = true;
            }
            
        } catch (error) {
            console.error('Error checking badge eligibility:', error);
        }
    }
    
    /**
     * Mint Safety Badge NFT
     */
    async mintSafetyBadge() {
        try {
            this.showLoading('Minting your Universal Safety Badge NFT...');
            
            const tx = await this.contract.mintSafetyBadge();
            await tx.wait();
            
            this.showSuccess('üéâ Safety Badge NFT minted successfully! You can now transfer it to any chain.');
            this.addTransactionStatus(tx.hash, 'Safety Badge Minted');
            
            await this.checkBadgeEligibility();
            
        } catch (error) {
            console.error('Error minting badge:', error);
            this.showError('Failed to mint badge: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    
    /**
     * Transfer Badge Cross-Chain (Universal NFT: Launch Everywhere)
     */
    async transferBadge() {
        try {
            const destinationChain = document.getElementById('transferChain').value;
            
            if (!destinationChain) {
                this.showError('Please select a destination chain');
                return;
            }
            
            const badgeTokenId = await this.contract.getUserBadge(this.userAddress);
            
            if (badgeTokenId.toNumber() === 0) {
                this.showError('You must mint a badge first');
                return;
            }
            
            this.showLoading('Transferring badge cross-chain...');
            
            const tx = await this.contract.transferBadgeCrossChain(badgeTokenId, destinationChain);
            await tx.wait();
            
            const chainNames = { 
                '11155111': 'Ethereum Sepolia', 
                '97': 'BSC Testnet', 
                '80001': 'Polygon Mumbai',
                '18000001': 'Solana Devnet',
                '18000002': 'Sui Testnet',
                '18000003': 'TON Testnet'
            };
            this.showSuccess(`üöÄ Badge transferred to ${chainNames[destinationChain]}! Universal NFT: Launch Everywhere achieved!`);
            this.addTransactionStatus(tx.hash, `Badge Transferred to ${chainNames[destinationChain]}`);
            
        } catch (error) {
            console.error('Error transferring badge:', error);
            this.showError('Failed to transfer badge: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    
    // ============ UTILITY FUNCTIONS ============
    
    addTransactionStatus(txHash, status) {
        const container = document.getElementById('statusContainer');
        
        if (container.querySelector('.no-positions') || container.querySelector('p')) {
            container.innerHTML = '';
        }
        
        const txItem = document.createElement('div');
        txItem.className = 'transaction-item';
        txItem.innerHTML = `
            <div><strong>${status}</strong></div>
            <div class="transaction-hash">TX: ${txHash}</div>
            <div>Time: ${new Date().toLocaleTimeString()}</div>
        `;
        
        container.insertBefore(txItem, container.firstChild);
    }
    
    showLoading(message) {
        document.body.classList.add('loading');
    }
    
    hideLoading() {
        document.body.classList.remove('loading');
    }
    
    showSuccess(message) {
        this.showMessage(message, 'success');
    }
    
    showError(message) {
        this.showMessage(message, 'error');
    }
    
    showMessage(message, type) {
        const existing = document.querySelector('.message');
        if (existing) existing.remove();
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${type}`;
        messageDiv.textContent = message;
        
        document.querySelector('.container').insertBefore(messageDiv, document.querySelector('.main-content'));
        
        setTimeout(() => messageDiv.remove(), 5000);
    }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    function initApp() {
        if (typeof ethers !== 'undefined') {
            console.log('Initializing Universal Portfolio Tracker...');
            new PortfolioTracker();
        } else {
            console.log('Waiting for ethers.js to load...');
            setTimeout(initApp, 100);
        }
    }
    initApp();
});
