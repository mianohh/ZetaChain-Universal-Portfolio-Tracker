// ZetaChain Universal Portfolio Tracker
// Universal App with Gateway Integration
// Architecture Generated by Amazon Q Developer

class PortfolioTracker {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.contract = null;
        this.userAddress = null;
        
        // TODO: Update this with the new Mainnet address after deployment
        this.CONTRACT_ADDRESS = "0x17Bc5d06c9e2B3593706d5Ed59f7D47E23959aCC";
        this.GATEWAY_ADDRESS = "0x6c533f7fe93fae114d0954697069df33c9b74fd7";
        
        // Extended ABI with Universal NFT functions
        this.CONTRACT_ABI = [
            "function deposit(uint256 amount) external payable",
            "function withdrawAndTrack(uint256 positionId, uint256 destinationChainId, address destinationAddress, uint256 gasLimit) external payable",
            "function getPosition(address user, uint256 positionId) external view returns (tuple(uint256 amount, address user, uint256 timestamp, uint8 status, bytes32 crossChainTxHash))",
            "function getUserPositions(address user) external view returns (tuple(uint256 amount, address user, uint256 timestamp, uint8 status, bytes32 crossChainTxHash)[])",
            "function estimateWithdrawGas(uint256 gasLimit) external view returns (uint256 baseGas, uint256 withPremium)",
            // Universal NFT Functions
            "function hasUsedSafetyBuffer(address user) external view returns (bool)",
            "function isEligibleForBadge(address user) external view returns (bool)",
            "function getUserBadge(address user) external view returns (uint256)",
            "function mintSafetyBadge() external",
            "function transferBadgeCrossChain(uint256 tokenId, uint256 destinationChainId) external",
            "function ownerOf(uint256 tokenId) external view returns (address)",
            "function tokenURI(uint256 tokenId) external view returns (string)",
            // Additional View Functions
            "function gateway() external view returns (address)",
            // Emergency Functions
            "function emergencyWithdraw(uint256 positionId) external",
            // Events
            "event PositionCreated(address indexed user, uint256 positionId, uint256 amount)",
            "event WithdrawInitiated(address indexed user, uint256 positionId, bytes32 txHash)",
            "event SafetyBufferUsed(address indexed user, uint256 positionId)",
            "event SafetyBadgeMinted(address indexed user, uint256 tokenId)",
            "event BadgeTransferredCrossChain(uint256 indexed tokenId, uint256 destinationChainId, address recipient)"
        ];
        
        this.init();
    }
    
    async init() {
        try {
            console.log('Initializing PortfolioTracker...');
            this.setupEventListeners();
            console.log('Event listeners setup complete');
            await this.checkWalletConnection();
            console.log('Wallet connection check complete');
        } catch (error) {
            console.error('Initialization error:', error);
        }
    }
    
    setupEventListeners() {
        try {
            document.getElementById('connectWallet').addEventListener('click', () => this.connectWallet());
            document.getElementById('depositBtn').addEventListener('click', () => this.createPosition());
            document.getElementById('withdrawBtn').addEventListener('click', () => this.withdrawPosition());
            document.getElementById('gasLimit').addEventListener('input', () => this.updateGasEstimate());
            document.getElementById('positionSelect').addEventListener('change', () => this.updateGasEstimate());
            
            // Universal NFT event listeners
            document.getElementById('mintBadgeBtn').addEventListener('click', () => this.mintSafetyBadge());
            document.getElementById('transferBadgeBtn').addEventListener('click', () => this.transferBadge());
            document.getElementById('transferChain').addEventListener('change', (e) => {
                document.getElementById('transferBadgeBtn').disabled = !e.target.value;
            });
            
            // Add refresh button listener
            const refreshBtn = document.getElementById('refreshPositions');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', () => this.forceRefresh());
            }
            
            console.log('All event listeners attached successfully');
        } catch (error) {
            console.error('Error setting up event listeners:', error);
        }
    }
    
    async checkWalletConnection() {
        if (typeof window.ethereum !== 'undefined') {
            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    await this.connectWallet();
                }
            } catch (error) {
                console.error('Error checking wallet connection:', error);
            }
        }
    }
    
    async connectWallet() {
        try {
            if (typeof window.ethereum === 'undefined') {
                this.showError('Please install MetaMask to use this application');
                return;
            }
            
            if (!this.CONTRACT_ADDRESS || this.CONTRACT_ADDRESS === "") {
                this.showError('Contract not deployed yet. Run: npm run deploy:universal');
                return;
            }
            
            // Verify contract exists
            const tempProvider = new ethers.providers.Web3Provider(window.ethereum);
            const code = await tempProvider.getCode(this.CONTRACT_ADDRESS);
            if (code === '0x') {
                this.showError(`Contract not found at ${this.CONTRACT_ADDRESS}. Please redeploy: npm run deploy:universal`);
                return;
            }
            
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            this.provider = new ethers.providers.Web3Provider(window.ethereum);
            this.signer = this.provider.getSigner();
            this.userAddress = await this.signer.getAddress();
            
            await this.switchToZetaChain();
            
            this.contract = new ethers.Contract(this.CONTRACT_ADDRESS, this.CONTRACT_ABI, this.signer);
            
            await this.updateWalletInfo();
            await this.loadPositions();
            await this.loadUserStats(); // NEW: Load user statistics
            await this.checkBadgeEligibility(); // NEW: Check NFT eligibility
            
            document.getElementById('connectWallet').style.display = 'none';
            document.getElementById('walletInfo').classList.remove('hidden');
            document.getElementById('depositBtn').disabled = false;
            
            this.showSuccess('Wallet connected successfully!');
            
        } catch (error) {
            console.error('Error connecting wallet:', error);
            this.showError('Failed to connect wallet: ' + error.message);
        }
    }
    
    async switchToZetaChain() {
        try {
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x1b58' }],
            });
        } catch (switchError) {
            if (switchError.code === 4902) {
                try {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x1b58',
                            chainName: 'ZetaChain Mainnet Beta',
                            nativeCurrency: {
                                name: 'ZETA',
                                symbol: 'ZETA',
                                decimals: 18
                            },
                            rpcUrls: ['https://zetachain-evm.blockpi.network/v1/rpc/public'],
                            blockExplorerUrls: ['https://zetachain.blockscout.com/']
                        }]
                    });
                } catch (addError) {
                    throw new Error('Failed to add ZetaChain network');
                }
            } else {
                throw switchError;
            }
        }
    }
    
    async updateWalletInfo() {
        const balance = await this.provider.getBalance(this.userAddress);
        document.getElementById('walletAddress').textContent = 
            `Address: ${this.userAddress.slice(0, 6)}...${this.userAddress.slice(-4)}`;
        document.getElementById('walletBalance').textContent = 
            `Balance: ${ethers.utils.formatEther(balance)} ZETA`;
    }
    
    async createPosition() {
        try {
            const amount = document.getElementById('depositAmount').value;
            if (!amount || parseFloat(amount) <= 0) {
                this.showError('Please enter a valid deposit amount');
                return;
            }
            
            // Check balance first
            const balance = await this.provider.getBalance(this.userAddress);
            const amountWei = ethers.utils.parseEther(amount);
            
            if (balance.lt(amountWei)) {
                this.showError(`Insufficient balance. You have ${ethers.utils.formatEther(balance)} ZETA but need ${amount} ZETA. Get more from: https://labs.zetachain.com/get-zeta`);
                return;
            }
            
            // Check network
            const network = await this.provider.getNetwork();
            if (network.chainId !== 7000) {
                this.showError('Wrong network! Please switch to ZetaChain Mainnet (Chain ID: 7000)');
                return;
            }
            
            this.showLoading('Creating position...');
            
            console.log('Sending transaction:', {
                amount: amount,
                amountWei: amountWei.toString(),
                balance: ethers.utils.formatEther(balance)
            });
            
            const tx = await this.contract.deposit(amountWei, { 
                value: amountWei,
                gasLimit: 500000
            });
            
            console.log('Transaction sent:', tx.hash);
            await tx.wait();
            console.log('Transaction confirmed');
            
            this.showSuccess('Position created successfully!');
            document.getElementById('depositAmount').value = '';
            
            // Wait a moment for blockchain state to update
            console.log('Waiting for blockchain state update...');
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            console.log('Reloading positions...');
            await this.loadPositions();
            await this.loadUserStats();
            await this.updateWalletInfo();
            
        } catch (error) {
            console.error('Error creating position:', error);
            
            // Better error messages
            let errorMsg = 'Failed to create position: ';
            
            if (error.code === 'INSUFFICIENT_FUNDS') {
                errorMsg = 'Insufficient ZETA balance. Get more from: https://labs.zetachain.com/get-zeta';
            } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                errorMsg = 'Transaction will fail. Check: 1) You have enough ZETA, 2) You\'re on ZetaChain Athens, 3) Contract is deployed correctly';
            } else if (error.message.includes('user rejected')) {
                errorMsg = 'Transaction cancelled by user';
            } else {
                errorMsg += error.message;
            }
            
            this.showError(errorMsg);
        } finally {
            this.hideLoading();
        }
    }
    
    /**
     * Load user statistics
     */
    async loadUserStats() {
        try {
            if (!this.contract || !this.userAddress) return;
            
            const positions = await this.contract.getUserPositions(this.userAddress);
            const activeCount = positions.filter(p => p.status === 0).length;
            const totalDep = positions.reduce((sum, p) => sum.add(p.amount), ethers.BigNumber.from(0));
            
            document.getElementById('positionCount').textContent = activeCount.toString();
            document.getElementById('totalDeposited').textContent = 
                `${ethers.utils.formatEther(totalDep)} ZETA`;
                
        } catch (error) {
            console.error('Error loading user stats:', error);
        }
    }
    
    async loadPositions() {
        try {
            if (!this.contract || !this.userAddress) {
                console.log('Cannot load positions: contract or address missing');
                return;
            }
            
            console.log('Loading positions for:', this.userAddress);
            console.log('Contract address:', this.CONTRACT_ADDRESS);
            
            const positions = await this.contract.getUserPositions(this.userAddress);
            console.log('Positions loaded:', positions.length, positions);
            
            // Log each position
            positions.forEach((pos, i) => {
                console.log(`Position ${i}:`, {
                    amount: ethers.utils.formatEther(pos.amount),
                    user: pos.user,
                    status: pos.status,
                    timestamp: new Date(pos.timestamp * 1000).toLocaleString()
                });
            });
            
            this.displayPositions(positions);
            this.updatePositionSelect(positions);
            
        } catch (error) {
            console.error('Error loading positions:', error);
            console.error('Error details:', error.message);
            this.showError('Failed to load positions: ' + error.message);
        }
    }
    
    displayPositions(positions) {
        const container = document.getElementById('positionsContainer');
        
        if (positions.length === 0) {
            container.innerHTML = '<p class="no-positions">No positions found. Create your first position above.</p>';
            return;
        }
        
        const statusNames = ['Active', 'Withdrawn', 'Refunded', 'Failed', 'Pending'];
        const statusClasses = ['status-active', 'status-withdrawn', 'status-refunded', 'status-failed', 'status-pending'];
        const statusIcons = ['âœ…', 'ðŸŽ¯', 'ðŸ”„', 'âŒ', 'â³'];
        
        container.innerHTML = positions.map((position, index) => `
            <div class="position-item">
                <div class="position-header">
                    <span class="position-id">Position #${index}</span>
                    <span class="position-status ${statusClasses[position.status]}">
                        ${statusIcons[position.status]} ${statusNames[position.status]}
                    </span>
                </div>
                <div class="position-details">
                    <div class="position-detail">
                        <strong>Amount</strong>
                        ${ethers.utils.formatEther(position.amount)} ZETA
                    </div>
                    <div class="position-detail">
                        <strong>Created</strong>
                        ${new Date(position.timestamp * 1000).toLocaleDateString()}
                    </div>
                    <div class="position-detail">
                        <strong>Status</strong>
                        ${statusNames[position.status]}
                    </div>
                </div>
            </div>
        `).join('');
    }
    
    updatePositionSelect(positions) {
        const select = document.getElementById('positionSelect');
        
        select.innerHTML = '<option value="">Choose a position to withdraw</option>';
        
        positions.forEach((position, index) => {
            if (position.status === 0) {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = `Position #${index} - ${ethers.utils.formatEther(position.amount)} ZETA`;
                select.appendChild(option);
            }
        });
        
        const hasActivePositions = positions.filter(p => p.status === 0).length > 0;
        select.disabled = !hasActivePositions;
        document.getElementById('withdrawBtn').disabled = !hasActivePositions;
    }
    
    async updateGasEstimate() {
        try {
            const gasLimit = document.getElementById('gasLimit').value;
            const positionId = document.getElementById('positionSelect').value;
            
            if (!gasLimit || !positionId || !this.contract) return;
            
            const [baseGas, withPremium] = await this.contract.estimateWithdrawGas(gasLimit);
            
            document.getElementById('gasEstimate').textContent = 
                `${ethers.utils.formatEther(baseGas)} ZETA`;
            document.getElementById('gasPremium').textContent = 
                `${ethers.utils.formatEther(withPremium)} ZETA`;
                
        } catch (error) {
            console.error('Error estimating gas:', error);
        }
    }
    
    async withdrawPosition() {
        try {
            const positionId = document.getElementById('positionSelect').value;
            const destinationChain = document.getElementById('destinationChain').value;
            const destinationAddress = document.getElementById('destinationAddress').value;
            const gasLimit = document.getElementById('gasLimit').value;
            
            if (!positionId || !destinationAddress || !gasLimit) {
                this.showError('Please fill in all withdrawal fields');
                return;
            }
            
            if (!ethers.utils.isAddress(destinationAddress)) {
                this.showError('Please enter a valid destination address');
                return;
            }
            
            const [, gasFee] = await this.contract.estimateWithdrawGas(gasLimit);
            
            this.showLoading('Initiating cross-chain withdrawal with Volatility Premium...');
            
            const tx = await this.contract.withdrawAndTrack(
                positionId,
                destinationChain,
                destinationAddress,
                gasLimit,
                { value: gasFee, gasLimit: 500000 }
            );
            
            await tx.wait();
            
            this.showSuccess('Withdrawal initiated! Safety Buffer used - Check your badge eligibility!');
            this.addTransactionStatus(tx.hash, 'Withdrawal Initiated (Volatility Premium Applied)');
            
            document.getElementById('positionSelect').value = '';
            document.getElementById('destinationAddress').value = '';
            
            await this.loadPositions();
            await this.loadUserStats();
            await this.updateWalletInfo();
            await this.checkBadgeEligibility(); // NEW: Recheck eligibility
            
        } catch (error) {
            console.error('Error withdrawing position:', error);
            this.showError('Failed to withdraw position: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    

    
    // ============ UNIVERSAL NFT FUNCTIONS ============
    
    /**
     * Check if user is eligible for Safety Badge NFT
     */
    async checkBadgeEligibility() {
        try {
            if (!this.contract || !this.userAddress) return;
            
            const isEligible = await this.contract.isEligibleForBadge(this.userAddress);
            const badgeTokenId = await this.contract.getUserBadge(this.userAddress);
            const hasBadge = badgeTokenId.toNumber() > 0;
            
            // Update UI based on status
            const badgeVisual = document.getElementById('badgeVisual');
            const badgeStatusText = document.getElementById('badgeStatusText');
            const badgeDescription = document.getElementById('badgeDescription');
            const badgeEligibility = document.getElementById('badgeEligibility');
            const mintBtn = document.getElementById('mintBadgeBtn');
            const transferChain = document.getElementById('transferChain');
            const transferBtn = document.getElementById('transferBadgeBtn');
            
            if (hasBadge) {
                // User has minted badge
                badgeVisual.className = 'badge-unlocked';
                badgeStatusText.textContent = 'Owned';
                badgeDescription.textContent = `You own Safety Badge #${badgeTokenId}. Transfer it to any chain!`;
                badgeEligibility.innerHTML = 'âœ… Badge Minted';
                badgeEligibility.className = 'eligibility-status eligible';
                mintBtn.disabled = true;
                mintBtn.textContent = 'âœ… Badge Already Minted';
                transferChain.disabled = false;
            } else if (isEligible) {
                // User is eligible to mint
                badgeVisual.className = 'badge-eligible';
                badgeStatusText.textContent = 'Eligible';
                badgeDescription.textContent = 'Congratulations! You used the Volatility Premium safely. Mint your Universal NFT badge now!';
                badgeEligibility.innerHTML = 'âœ… Eligible to Mint';
                badgeEligibility.className = 'eligibility-status eligible';
                mintBtn.disabled = false;
            } else {
                // User not eligible yet
                badgeVisual.className = 'badge-locked';
                badgeStatusText.textContent = 'Locked';
                badgeDescription.textContent = 'Complete a safe withdrawal using the Volatility Premium to unlock your Universal NFT badge.';
                badgeEligibility.innerHTML = 'âŒ Not Eligible Yet';
                badgeEligibility.className = 'eligibility-status';
                mintBtn.disabled = true;
            }
            
        } catch (error) {
            console.error('Error checking badge eligibility:', error);
        }
    }
    
    /**
     * Mint Safety Badge NFT
     */
    async mintSafetyBadge() {
        try {
            // Double-check eligibility before minting
            const badgeTokenId = await this.contract.getUserBadge(this.userAddress);
            if (badgeTokenId.toNumber() > 0) {
                this.showError('You have already minted your badge!');
                await this.checkBadgeEligibility();
                return;
            }
            
            const isEligible = await this.contract.isEligibleForBadge(this.userAddress);
            if (!isEligible) {
                this.showError('Not eligible yet. Complete a withdrawal first.');
                return;
            }
            
            this.showLoading('Minting your Universal Safety Badge NFT...');
            
            const tx = await this.contract.mintSafetyBadge();
            await tx.wait();
            
            // Download NFT image
            await this.downloadNFTImage();
            
            this.showSuccess('ðŸŽ‰ Safety Badge NFT minted successfully! Image downloaded to your device.');
            this.addTransactionStatus(tx.hash, 'Safety Badge Minted');
            
            await this.checkBadgeEligibility();
            
        } catch (error) {
            console.error('Error minting badge:', error);
            if (error.message.includes('Badge already minted')) {
                this.showError('Badge already minted! Check your wallet.');
                await this.checkBadgeEligibility();
            } else {
                this.showError('Failed to mint badge: ' + error.message);
            }
        } finally {
            this.hideLoading();
        }
    }
    
    /**
     * Download NFT image to user's device
     */
    async downloadNFTImage() {
        try {
            const badgeTokenId = await this.contract.getUserBadge(this.userAddress);
            const tokenURI = await this.contract.tokenURI(badgeTokenId);
            
            // Parse JSON metadata
            const jsonData = tokenURI.replace('data:application/json;utf8,', '');
            const metadata = JSON.parse(jsonData);
            const imageUrl = metadata.image;
            
            // Fetch and download image
            const response = await fetch(imageUrl);
            const blob = await response.blob();
            
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `zetachain-safety-badge-${badgeTokenId}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
            
        } catch (error) {
            console.error('Error downloading NFT image:', error);
        }
    }
    
    /**
     * Transfer Badge Cross-Chain (Universal NFT: Launch Everywhere)
     */
    async transferBadge() {
        try {
            const destinationChain = document.getElementById('transferChain').value;
            
            if (!destinationChain) {
                this.showError('Please select a destination chain');
                return;
            }
            
            const badgeTokenId = await this.contract.getUserBadge(this.userAddress);
            
            if (badgeTokenId.toNumber() === 0) {
                this.showError('You must mint a badge first');
                return;
            }
            
            this.showLoading('Transferring badge cross-chain...');
            
            const tx = await this.contract.transferBadgeCrossChain(badgeTokenId, destinationChain);
            await tx.wait();
            
            const chainNames = { 
                '1': 'Ethereum Mainnet', 
                '56': 'BSC Mainnet', 
                '137': 'Polygon Mainnet',
                '18000001': 'Solana Devnet',
                '18000002': 'Sui Testnet',
                '18000003': 'TON Testnet'
            };
            this.showSuccess(`ðŸš€ Badge transferred to ${chainNames[destinationChain]}! Universal NFT: Launch Everywhere achieved!`);
            this.addTransactionStatus(tx.hash, `Badge Transferred to ${chainNames[destinationChain]}`);
            
        } catch (error) {
            console.error('Error transferring badge:', error);
            this.showError('Failed to transfer badge: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    
    // ============ UTILITY FUNCTIONS ============
    
    async forceRefresh() {
        console.log('Force refreshing all data...');
        this.showLoading('Refreshing...');
        try {
            await this.loadPositions();
            await this.loadUserStats();
            await this.updateWalletInfo();
            await this.checkBadgeEligibility();
            this.showSuccess('Data refreshed!');
        } catch (error) {
            console.error('Refresh error:', error);
            this.showError('Refresh failed: ' + error.message);
        } finally {
            this.hideLoading();
        }
    }
    
    addTransactionStatus(txHash, status) {
        const container = document.getElementById('statusContainer');
        
        if (container.querySelector('.no-positions') || container.querySelector('p')) {
            container.innerHTML = '';
        }
        
        const txItem = document.createElement('div');
        txItem.className = 'transaction-item';
        txItem.innerHTML = `
            <div><strong>${status}</strong></div>
            <div class="transaction-hash">TX: ${txHash}</div>
            <div>Time: ${new Date().toLocaleTimeString()}</div>
        `;
        
        container.insertBefore(txItem, container.firstChild);
    }
    
    showLoading(message) {
        const overlay = document.getElementById('loadingOverlay');
        const text = document.getElementById('loadingText');
        if (overlay && text) {
            text.textContent = message;
            overlay.classList.remove('hidden');
        }
    }
    
    hideLoading() {
        const overlay = document.getElementById('loadingOverlay');
        if (overlay) {
            overlay.classList.add('hidden');
        }
    }
    
    showSuccess(message) {
        this.showToast(message, 'success');
    }
    
    showError(message) {
        this.showToast(message, 'error');
    }
    
    showToast(message, type) {
        const container = document.getElementById('toastContainer');
        if (!container) return;
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.innerHTML = `<div class="toast-message">${message}</div>`;
        
        container.appendChild(toast);
        
        setTimeout(() => {
            toast.style.animation = 'slideOut 0.3s ease';
            setTimeout(() => toast.remove(), 300);
        }, 5000);
    }
}

// Initialize the application
document.addEventListener('DOMContentLoaded', () => {
    function initApp() {
        if (typeof ethers !== 'undefined') {
            console.log('Initializing Universal Portfolio Tracker...');
            window.tracker = new PortfolioTracker();
            console.log('Tracker instance available as window.tracker');
        } else {
            console.log('Waiting for ethers.js to load...');
            setTimeout(initApp, 100);
        }
    }
    initApp();
});

// Debug helper
window.debugPositions = async function() {
    if (!window.tracker || !window.tracker.contract) {
        console.error('Tracker not initialized or wallet not connected');
        return;
    }
    
    console.log('=== DEBUG INFO ===');
    console.log('User Address:', window.tracker.userAddress);
    console.log('Contract Address:', window.tracker.CONTRACT_ADDRESS);
    
    try {
        const count = await window.tracker.contract.getPositionCount(window.tracker.userAddress);
        console.log('Position Count:', count.toString());
        
        const positions = await window.tracker.contract.getUserPositions(window.tracker.userAddress);
        console.log('Raw Positions:', positions);
        
        positions.forEach((pos, i) => {
            console.log(`Position ${i}:`, {
                amount: ethers.utils.formatEther(pos.amount),
                user: pos.user,
                status: pos.status,
                timestamp: pos.timestamp.toString()
            });
        });
    } catch (error) {
        console.error('Debug error:', error);
    }
};
