// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title OmnichainTracker - Universal AI App
 * @notice Cross-chain portfolio tracker with gamified Safety Badge NFTs
 * @dev Implements Universal NFT: Mint Once, Launch Everywhere
 * @custom:bounty Hackathon Bounty #2 (Universal AI App) & #3 (Multi-Sponsor)
 * @custom:attribution Volatility Premium Algorithm & Architecture Generated by Amazon Q
 */
contract OmnichainTracker is ERC721, Ownable {
    // ============ State Variables ============
    
    address public gateway;
    uint256 private _tokenIdCounter;
    
    // Position tracking
    struct Position {
        uint256 amount;
        address user;
        uint256 timestamp;
        PositionStatus status;
        bytes32 crossChainTxHash;
    }
    
    enum PositionStatus {
        Active,
        Withdrawn,
        Refunded,
        Failed
    }
    
    // Mappings
    mapping(address => Position[]) public userPositions;
    mapping(bytes32 => uint256) public txHashToPositionId;
    mapping(address => uint256) public totalDeposited;
    
    // ============ Universal NFT State ============
    
    mapping(address => bool) public hasUsedSafetyBuffer;
    mapping(address => uint256) public userBadgeTokenId;
    mapping(uint256 => bool) public badgeTransferredCrossChain;
    
    // ============ Events ============
    
    event PositionCreated(address indexed user, uint256 positionId, uint256 amount);
    event WithdrawInitiated(address indexed user, uint256 positionId, bytes32 txHash);
    event SafetyBufferUsed(address indexed user, uint256 positionId);
    event SafetyBadgeMinted(address indexed user, uint256 tokenId);
    event BadgeTransferredCrossChain(uint256 indexed tokenId, uint256 destinationChainId, address recipient);
    event RevertSuccess(address indexed user, uint256 positionId, bytes32 txHash, string reason);
    event PositionRefunded(address indexed user, uint256 positionId, uint256 amount);
    
    // ============ Constructor ============
    
    constructor(address _gateway) ERC721("ZetaChain Safety Badge", "ZCSB") Ownable(msg.sender) {
        gateway = _gateway;
        _tokenIdCounter = 1;
    }
    
    // ============ Core Functions ============
    
    /**
     * @notice Deposit funds to create a new position
     * @param amount Amount to deposit
     */
    function deposit(uint256 amount) external payable {
        require(amount > 0, "Amount must be greater than 0");
        require(msg.value >= amount, "Insufficient value sent");
        
        Position memory newPosition = Position({
            amount: amount,
            user: msg.sender,
            timestamp: block.timestamp,
            status: PositionStatus.Active,
            crossChainTxHash: bytes32(0)
        });
        
        userPositions[msg.sender].push(newPosition);
        totalDeposited[msg.sender] += amount;
        
        emit PositionCreated(msg.sender, userPositions[msg.sender].length - 1, amount);
    }
    
    /**
     * @notice Withdraw position with Volatility Premium safety mechanism
     * @dev Amazon Q Generated: 30% Volatility Premium for cross-chain safety
     * @param positionId Position index to withdraw
     * @param destinationChainId Destination chain selector
     * @param destinationAddress Recipient address on destination chain
     * @param gasLimit Base gas limit for destination execution
     */
    function withdrawAndTrack(
        uint256 positionId,
        uint256 destinationChainId,
        address destinationAddress,
        uint256 gasLimit
    ) external payable {
        Position storage position = userPositions[msg.sender][positionId];
        
        require(position.user == msg.sender, "Not position owner");
        require(position.status == PositionStatus.Active, "Position not active");
        require(position.amount > 0, "Position empty");
        
        // ============ AMAZON Q GENERATED: Volatility Premium Algorithm ============
        uint256 baseGasFee = 0.001 ether;
        uint256 volatilityPremium = (baseGasFee * 30) / 100; // 30% safety buffer
        uint256 totalGasFee = baseGasFee + volatilityPremium;
        
        require(msg.value >= totalGasFee, "Insufficient gas fee sent");
        
        // Generate transaction hash
        bytes32 txHash = keccak256(
            abi.encodePacked(msg.sender, positionId, block.timestamp, destinationChainId)
        );
        
        // Update position state
        position.status = PositionStatus.Withdrawn;
        position.crossChainTxHash = txHash;
        txHashToPositionId[txHash] = positionId;
        
        // ============ GAMIFICATION: Track Safety Buffer Usage ============
        if (!hasUsedSafetyBuffer[msg.sender]) {
            hasUsedSafetyBuffer[msg.sender] = true;
            emit SafetyBufferUsed(msg.sender, positionId);
        }
        
        emit WithdrawInitiated(msg.sender, positionId, txHash);
        
        // Simulate revert for stress testing
        if (gasLimit < 150000) {
            _simulateRevert(msg.sender, positionId, txHash);
        }
    }
    
    /**
     * @notice Simulate revert for testing
     */
    function _simulateRevert(address user, uint256 positionId, bytes32 txHash) internal {
        Position storage position = userPositions[user][positionId];
        position.status = PositionStatus.Refunded;
        
        emit RevertSuccess(user, positionId, txHash, "Destination execution failed - position refunded");
        emit PositionRefunded(user, positionId, position.amount);
    }
    
    // ============ Universal NFT Functions ============
    
    /**
     * @notice Mint Safety Badge NFT (Universal NFT - Mint Once)
     * @dev Only eligible users who used the safety buffer can mint
     */
    function mintSafetyBadge() external {
        require(hasUsedSafetyBuffer[msg.sender], "Not eligible: Must use safety buffer first");
        require(userBadgeTokenId[msg.sender] == 0, "Badge already minted");
        
        uint256 tokenId = _tokenIdCounter++;
        _safeMint(msg.sender, tokenId);
        
        userBadgeTokenId[msg.sender] = tokenId;
        
        emit SafetyBadgeMinted(msg.sender, tokenId);
    }
    
    /**
     * @notice Transfer Badge Cross-Chain (Launch Everywhere)
     * @dev Demonstrates Universal NFT cross-chain capability
     * @param tokenId The badge token ID to transfer
     * @param destinationChainId Target chain (1=Ethereum, 56=BSC, 137=Polygon)
     */
    function transferBadgeCrossChain(
        uint256 tokenId,
        uint256 destinationChainId
    ) external {
        require(ownerOf(tokenId) == msg.sender, "Not badge owner");
        require(!badgeTransferredCrossChain[tokenId], "Already transferred cross-chain");
        
        // Mark as transferred
        badgeTransferredCrossChain[tokenId] = true;
        
        // In production: Use ZetaChain connector.send() for actual cross-chain transfer
        // For demo: Emit event to show cross-chain intent
        emit BadgeTransferredCrossChain(tokenId, destinationChainId, msg.sender);
    }
    
    // ============ View Functions ============
    
    /**
     * @notice Check if user is eligible for Safety Badge
     */
    function isEligibleForBadge(address user) external view returns (bool) {
        return hasUsedSafetyBuffer[user] && userBadgeTokenId[user] == 0;
    }
    
    /**
     * @notice Get user's badge token ID
     */
    function getUserBadge(address user) external view returns (uint256) {
        return userBadgeTokenId[user];
    }
    
    /**
     * @notice Get user's position by ID
     */
    function getPosition(address user, uint256 positionId) 
        external 
        view 
        returns (Position memory) 
    {
        require(positionId < userPositions[user].length, "Invalid position ID");
        return userPositions[user][positionId];
    }
    
    /**
     * @notice Get all positions for a user
     */
    function getUserPositions(address user) 
        external 
        view 
        returns (Position[] memory) 
    {
        return userPositions[user];
    }
    
    /**
     * @notice Calculate gas fee with volatility premium
     * @dev Amazon Q Generated Algorithm
     */
    function estimateWithdrawGas(uint256 /* gasLimit */) 
        external 
        pure 
        returns (uint256 baseGas, uint256 withPremium) 
    {
        baseGas = 0.001 ether;
        uint256 premium = (baseGas * 30) / 100;
        withPremium = baseGas + premium;
    }
    
    /**
     * @notice Emergency withdrawal
     */
    function emergencyWithdraw(uint256 positionId) external {
        Position storage position = userPositions[msg.sender][positionId];
        require(position.user == msg.sender, "Not position owner");
        require(position.status == PositionStatus.Active, "Position not active");
        
        position.status = PositionStatus.Failed;
        payable(msg.sender).transfer(position.amount);
    }
    
    /**
     * @notice Override tokenURI for badge metadata
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(ownerOf(tokenId) != address(0), "Token does not exist");
        
        // For demo: Use GitHub raw URL or your server URL
        // Replace with your actual badge.svg URL
        string memory imageUrl = "https://raw.githubusercontent.com/mianohh/ZetaChain-Omnichain-Portfolio-Tracker/main/badge.svg";
        
        string memory json = string(abi.encodePacked(
            '{"name":"ZetaChain Safety Badge #',
            _toString(tokenId),
            '","description":"Certified Safety Buffer User - Universal NFT","image":"',
            imageUrl,
            '","attributes":[{"trait_type":"Type","value":"Safety Certified"},{"trait_type":"Network","value":"Universal"}]}'
        ));
        
        return string(abi.encodePacked(
            "data:application/json;utf8,",
            json
        ));
    }
    
    function _toString(uint256 value) internal pure returns (string memory) {
        if (value == 0) return "0";
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
}
